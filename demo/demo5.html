<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>模版匹配</title>
</head>

<body>
  <img id="whole" src="../img/lena.jpg" alt="" />
  <img id="template" src="../img/lena-part.jpg" alt="" />
  <canvas id="result"></canvas>
  <canvas id="dst"></canvas>
  <canvas id="threshold"></canvas>
  <script src="../lib/opencv.js" type="text/javascript"></script>
  <script src="./tool.js"></script>
  <script>
    window.onload = function () {
      let $whole = document.querySelector('#whole')
      let src = cv.imread($whole)

      let $template = document.querySelector('#template')
      let templ = cv.imread($template)

      let dst = new cv.Mat()

      //计算模版图像中的最小值
      let planes1 = new cv.MatVector()
      cv.split(templ, planes1)
      let rChannel = planes1.get(0)
      let rLoc = cv.minMaxLoc(rChannel)
      let minR = getChannels(rChannel, rLoc.minLoc.y, rLoc.minLoc.x)[0] //模版图像的最小R通道

      let gChannel = planes1.get(1)
      let gLoc = cv.minMaxLoc(gChannel)
      let minG = getChannels(gChannel, gLoc.minLoc.y, gLoc.minLoc.x)[0] //模版图像的最小G通道

      let bChannel = planes1.get(2)
      let bLoc = cv.minMaxLoc(bChannel)
      let minB = getChannels(bChannel, bLoc.minLoc.y, bLoc.minLoc.x)[0] //模版图像最小B通道

      //过滤源图像
      let planes2 = new cv.MatVector()
      cv.split(src, planes2)
      /**
       * 阀值化
       * threshold( src,dst, thresh, maxval, type )
       * 参数说明：
       * src 源图像
       * dst 输出图像
       * thresh 门限值
       * maxval 最大值
       * type 函数类型
       * cv.THRESH_TOZERO 表示如果目标值大于门限值则取目标值否则取 0
       */
      cv.threshold(
        planes2.get(0),
        planes2.get(0),
        minR - 1, //减1
        255,
        cv.THRESH_TOZERO
      )
      cv.threshold(
        planes2.get(1),
        planes2.get(1),
        minG - 1,
        255,
        cv.THRESH_TOZERO
      )
      cv.threshold(
        planes2.get(2),
        planes2.get(2),
        minB - 1,
        255,
        cv.THRESH_TOZERO
      )
      cv.merge(planes2, src)

      /**
       *
       * cv.matchTemplate(src, templ, dst, method)
       * src 源图像 尺寸 W/H
       * templ 模版图像 尺寸 w/h
       * dst 匹配结果 尺寸 (W-w+1)/(H-h+1)
       * method 模版匹配方法
       *
       * opencv中模版匹配支持的比较方法有六种：
       * cv.TM_SQDIFF 平方差匹配 匹配值越大，匹配越差；
       * cv.TM_SQDIFF_NORMED 标准平方差匹配；
       * cv.TM_CCORR 相关性匹配 该方法使用源图像与模版图像的卷积结果进行匹配，匹配值越小结果越差；
       * cv.TM_CCORR_NORMED 归一化相关性匹配；
       * cv.TM_CCOEFF 相关性系数匹配方法，该方法使用源图像与其均值的差、模版与其均值的差二者之间的相关性进行匹配，正值表示匹配的结果较好，负值表示匹配的结果较差；匹配值越大，匹配效果越好；
       * cv.TM_CCOEFF_NORMED 归一化相关性系数匹配方法。
       *
       */
      cv.matchTemplate(src, templ, dst, cv.TM_CCOEFF_NORMED)

      /**
       * cv.normalize(src, dst, a, b, normal_type)
       * 根据 normal_type 的不同值，图像 src 将被规范化，或者以其他方式映射到 dst 的一个特定范围内
       * cv.NORM_MINMAX 表示把 src 映射到 [a,b] 的范围上
       */
      cv.normalize(dst, dst, 0, 1, cv.NORM_MINMAX)

      /**
       * cv.minMaxLoc(arr)
       * 找出数组 arr 中的最大值和最小值，并返回它们的位置（只可以用来处理单通道数组）
       */
      let position = cv.minMaxLoc(dst)
      let maxPoint = position.maxLoc
      let color = new cv.Scalar(255, 0, 0, 255)
      let point = new cv.Point(
        maxPoint.x + templ.cols,
        maxPoint.y + templ.rows
      )

      /**
       * 绘制矩形
       * cv.rectangle(src, p1, p2, color, line_width, line_type);
       * src 源图像
       * p1 矩形对角线顶点1
       * p2 矩形对角线顶点2
       * color 线条颜色
       * line_width 线条宽度
       * line_type 线条类型 cv.LINE_8 8连通线条，较为平滑不会走样
       */
      cv.rectangle(src, maxPoint, point, color, 1, cv.LINE_8)
      cv.imshow('result', src)
      cv.imshow('dst', dst)

      templ.delete()
      src.delete()
      dst.delete()
    }
  </script>
</body>

</html>